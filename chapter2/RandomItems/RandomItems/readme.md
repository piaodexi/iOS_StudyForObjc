
#chap2 objc

- 메시지란   
클래스나 객체에게 메소드를 실행하도록 요청하는 행위   
- 메소드란 
실행가능한 코드의 모음.  

- RandomItems의 초기 버전에서는 네 개의 문자열을 가진 배열(array)을 만듬.
배열은 다른 객체의 포인터들을 가진 순차적인 목록임.   
베열 내의 포인터는 인덱스(index)로 접근가능함.   

- objc에서 배열은 객체를 직접 포함하지 않는다. 
대신에 각 객체에 대한 포인터를 저장한다. 객체가 배열에 추가되면 메모리상의 객체 주소가 배열안에 저장됨.  

- NSString
문자열을 저장하고 다루는 기능이 추가됨. 해당 문자열의 문자 개수를 반환하는 length 메소드 등이 있음.  
- NSArray
순차적인 목록을 관리하는 기능이 추가됨. 주어진 인덱스에 해당하는 객체를 반환하고 (objectAtIndex: ) 배열 내의 객체 수를 반환하는 메소드 (count)등을 가지고 있음.   
- NSMuatableArray
NSArray의 기능에 포인터를 추가하거나 제거하는 기능이 추가됨 . 

- 헤더 파일h
헤더파일은 새 클래스 이름, 상위 클래스, 인스턴스 변수, 구현할 메소드 등을 선한다. 

- 구현 파일m
구현파일은 클래스가 구현하는 메소드의 실제 코드를 가지고 있음. 

- objc에서 클래스를 선언할려면, @interface  키워드를 클래스 이름 앞에 사용한다.   
그 후 콜론(:) 다음에 상위 클래스 이름이 온다. objc는 단일 상속만을 허용하기 때문에 모든 클래스는 오직 하나의 상위클래스를 가질 수 있다.    
@interface ClassName : SuperclassName.  
@end는 클래스 선언의 끝을 가르킨다. 

- objc는 c언어의 키워드들을 포함하는데 objc에서 추가된 키워드는 @접두사로 구별가능함.   

- 클래스의 인스턴스 변수는 클래스 선언 다음의 중괄호 {} 사이에 선언함. 

- 인스턴스 변수에 접근하기 
객체지향 언어에서 인스턴스 변수를 가져오거나 설정하는 메소드를 접근자(accessor)라 하고 각각 게터(getter)세터(setter)라 부른다 객체는 이들 메소드 없이 다른 객체의 인스턴스 변수에 접근할 수 없음. 

# 클래스 메소드 vs 인스턴스 메소드 
메소드에는 인스턴스 메소드와 클래스 메소드라는 두 종류가 있다. 일반적으로 클래스 메소드는 클래스의 새 인스턴스를 만들거나 클래스의 전역 프로퍼티를 읽어온다. 인스턴스 메소드는 클래스의 특정 인스턴스에 영향을 미친다. 예를 들면, bnritem에서 중괄호 치고 구현한 접근자들은 모두 인스턴스 메소드이다. 이 메소드들을 이용해 특정 객체의 인스턴스 변수를 설정하거나 가져옴.   

인스턴스 메소드를 호출하려면 클래스 인스턴스에 메시지를 보낸다. 클래스 메소드를 호출하려면 클래스 그 자체에 메시지를 보낸다.   
예를 들어 BNRItem의 인스턴스를 만들려면 BNRItem 클래스에 alloc(클래스 메소드) 메시지를 보내고 alloc 메소드가 반환한 BNRItem의 인스턴스에 init (인스턴스 메소드) 메시지를 보냄.  

# 메소드 재정위
하위 클래스는 자신의 상위 클래스의 메소드를 재정의할 수 있다. (overrride) 예를 들어 nsobject 인스턴스에 description 메시지를 보내면 해당 객체 클래스 이름과 메모리 주소를 다음과 같이 NSString의 인스턴스로 반환한다. 
<BNRQuizViewController: 0x4b22a0>    
nsobject의 하위 클래스는 이 메소드를 하위 클래스 인스턴스에 알맞는 내용을 가진 nsstring 객체를 반환하도록 재정의 할 수 있다.
예를 들어 nsstring 클래스는 description 메소드를 재정의 해 배열 안의 모든 객체의 설명을 반환한다.   
BNRItem도 NSObject(원래의 description 메소드가 선언된 클래스)의 하위 클래스이기 때문에 BNRItem에서 description메소드를 다시 구현하면 이 또한 메서드 재정의이다.   
메소드를 재정의 할 때 구현 파일에서 정의하면 된다. 이미 상위 클래스에 해당 메소드가 정의되어 있기 때문에 헤더에 할필요가 없음. 

#초기화 메소드 
초기화 메소드는 init 이라는 단어로 시작한다. 이러한 초기화 메소드 명명법이 다른 인스턴스 메소드와 어떠한 차이를 만들어내는 것은 아니다. 근데 옵씨에선 엄격하니깐 그냥 따르자.   
초기화 메소드는 객체를 초기화하는데 필요한 인자를 가짐. 인스턴스는 다른 초기화 방식이 필요한 경우가 있기 때문에 종종 클래스는 여러 초기화 메소드를 가짐. 일례로 어떤 초기화메소드는 값 3개를 초기화해야될때도 잇고 어떤건 하나만 해도 될때도 잇고 선택의 영역임

#지정 초기화 메소드 
클래스는 초기화 메소드를 여러 개 가질 수 있다. 다만 그 중에 하나의 메소드가 지정 초기화 메소드로 선택된다.   
지정 초기화 메소드는 객체의 모든 인스턴스 변수를 유효하게 만든다. ("유효하다" 는 것은 객체 초기화 후에 메시지를 보낼 때 결과를 예측할 수 있고 아무런 문제가 없음을 뜻한다.).  
일반적으로 지정 초기화 메소드는 가장 중요하고 자주 사용되는 인스턴스 변수를 인자로 가진다. BNRItem클래스는 네 개의 인스턴스 변수를 갖지만 이 중 3개만 쓰기 가능하다. 그러므로 BNRItem의 지정 초기화 메소드는 세 개의 인자를 받아들여야 하고 구현부에서 _dateCreated에 대한 값을 제공해야 한다. 

#instancetype
instancetype 키워드는 반환 타입으로만 사용할 수 있고 그 반환 타입은 메시지의 리시버와 일치한다. init 메소드는 항상 instancetype을 반환하도록 선언된다.   

왜 BNRItem 클래스에서 BNRItem *가 반환타입이 아닐까 그건 하위 클래스를 가진 경우 문제가 될 수 있기 때문임. 하위 클래스는 BNRItem에서 초기화 메소드와 그 반환 타입까지 포함해 모든 메소드를 상속받는다. 하위 클래스의 인스턴스가 이 초기화 메시지를 받으면 무엇을 반환하게 될까? BNRItem인스턴스에 대한 포인터가 아닌 하위 클래스의 인스턴스 포인터를 반환해야한다. 그럼 하위 클래스에서 초기화 메소드를 재정의 하여 반환 타입을 변경하도록 하면 아무 문제가 없을거라고 생각될지도 모르겠지만 objc에서는 같은 셀렉터와 다른 반환 타입을 가진 형태의 메소드를 여러개 가질 수 없다 . (자바의 overload?를 말하는듯).  
따라서 초기화 메소드가 "메시지를 받는 객체의 인스턴스"를 반환하도록 지정하면 이러한 상황에서도 걱정 노 

#id
objc에 instancetype 키워드가 생기기 전에는 초기화 메소드가 id를 반환했다. 이 타입은 " 임의의 객체에 대한 포인터"로 정의 되어 있다. (id는 c언어의 void와 유사함) 현재도 Xcode 클래스 탬플릿은 여전히 초기화 메소드의 반환 타입으로 id를 코드에 삽입한다.   
id는 instanctype과 달리 반환 타입 외에도 다양하게 사용 할 수 있다. 객체의 타입이 확실한 경우 id타입의 변수나 메소드 인자를 선언할 수 있다.   
id objectOfUnknownType;   
객체의 타입을 모르거나 복수의 타입을 가진 배열을 순회하기 위해 빠른 열거를 사용할 경우에도 id를 사용할 수 있다. 
for (id item in items) {
nslog(@"%@",item);
}   
id는 "임의의 객체에 대한 포인터"로 정의돼 있기 때문에 id 타입의 변수나 메소드인자를 선언할 때 *를 포함하면 안된다. 

#self
메소드 내부에서 self는 암시적 지역 변수임. 따로 선언할 필요 없이 자동으로 메시지를 받을 객체를 가리키도록 설정됨 (대다수 객체지향 언어가 이러한 개념을 가지고 있지만 일부에서는 self 대신에 this라고 함 (아마자바?)) 일반적으로 self는 객체가 그 자신에게 메시지를 보내기 위해 사용됨.   
init 메소드의 마지막 줄에서 항상 새로 초기화한 객체를 반환한다. 호출자는 그 값을 변수에 할당할 수 있다.   
return self;   

#super
메소드를 재정의할 때 상위 클래스의 메소드를 그대로 사용하면서 뭔가 새로 추가하고 싶을때가 있을 것이다. objc에서  컴파일러 지시자인 super를 사용하면 그렇게 하기 쉬움.  
super는 어떻게 동작할까? 객체에 메시지를 보내면 객체 클래스에서 그 메소드명을 찾기 시작함. 찾는 메소드가 없다면 그 상위 클래스에서 계속해서 검색함. 알맞은 메소드를 찾을 때까지 계속해서 상속계층을 따라 검색함. (만약 최상위 계층에서도 메소드를 찾지 못하면 exception이 발생함.).  
super에 메시지를 보내면 메시지는 self로 가지만 현 객체 클래스를 건너뛰고 상위클래스에서 메소드를 찾는다. BNRItem의 지정 초기화 메소드에서는 init메시지를 super에 보낸다. 이는 NSObejct의 init 메소드를 호출한다.

#초기화 성공 여부 확인하기 
상위 클래스의 초기화 메소들ㄹ 호출한 다음에는 그반환값을 확인해야 한다. 만약 초기화 메시지가 실패하면 nil을 반환할 것이다. 따라서 상위 클래스의 초기화 메소드 반환값을 self 변수에 저장하여 하위 클래스에서 추가로 초기화하기 전에 그 값이 nil이 아닌지 확인한다. 

#초기화 메소드의 규칙
- 클래스는 상위 클래스로부터 모든 초기화 메소드를 상속받고 우너하는 만큼 추가할 수 있다.
- 각 클래스는 하나의 초기화 메소드를 지정 초기화 메소드로 선택한다.
- 지정 초기화 메소드는 제일 먼저 상위 클래스의 지정 초기화 메소드를 호출한다.
- 다른 초기화 메소드는 클래스의 지정 초기화 메소드를 호출한다ㅣ.
- 클래스가 상위 클래스와 다른 지정 초기화 메소드를 선언하면 새 지정 초기화 메소드를 호출하도록 상위 클래스의 지정 초기화 메소드를 반드시 제정의 해야한다. 

#클래스 메소드 
클래스 메소드는 보통 클래스의 새 인스턴스를 만들거나 클래스의 전역 프로퍼티를 가져온다. 클래스 메소드는 인스턴스에서 동작하지 않고 어떤 인스턴스 변수에도 접근하지 않는다.   
클래스 메소드는 문법적으로 선언할 때 인스턴스 메소드와 다르다. 클래스 메소드의 선언은 인스턴스 메소드 선언과 첫 번째 문자가 다르다. 인스턴스 메소드는 반환 타입 앞에 -가로를 사용하고 클래스 메소드는 +기호를 사용한다. 

#NSArray와 NSMutableArray 
objc 배열은 여러 타입의 객체를 포함할 수 있다. 예를 들어 items  배열은 BNRItem 인스턴스들만을 포함하고 있지만 NSDate 인스턴스나 다른 objc 객체를 추가할 수 있다. 이는 배열에 한가지 타입의 객체만 저장해야하는 다른 강타입(strongly)언어들과 다른 점이다.   
단 objc 배열은 objc 객체에 대한 참조만을 저장할 수 있다. 기본형과 c구조체는 objc 배열에 추가할 수 없다. 만약 기본형이나 c구조체를 저장할려면 nsnumber,nsvalue, nsdata와 같은 objc 객체로 해당 데이터를 감싸 사용할 수 있다.   
또한 배열에 nil을 추가할 수 없음. 만약 배열에 nil을 추가하고자 한다면 반드시 nsnull을 사용해야함. nsnull은 nil을 대신하는 인스턴스를 가진 클래스로 이처럼 특수한 경우에만 사용함.   
[items addObject:[NSNUll null]];   
배열의 멤버에 접근할 때는 얻고자 하는 객체의 인덱스와 함깨 objectAtIndex: 메시지를 보낸다. 이는 objc의 다른 요소들과 마찬가지로 매우 긴 표현임.   
그래서 배열의 멤버에 접근하는 단축 문법이 존재함.   
NSString *foo = items[0];   
위 코드는 다음과 같이 items 배열에 objectAtIndex: 메시지를 보낸 것과 동일하다 .   
NSString *foo = [items objectAtIndex:0];   
   
NSMutableArray에서도 유사한 문법으로 객체를 추가하거나 대체할 수 있다.   
NSMutableArray *items = [[NSMutable alloc]init];
items[0] = @"A";
items[1] = @"B";
items[0] = @"C"; //A를 C로 교체.  
위 코드는 items에 insertObject:atIndex: 메시지와 replaceObjectAtIndex:withObject: 메시지를 보낸것과 동일하다. 

#예외와 인식할 수 없는 셀렉터 
실행중에 객체에 메시지를 보내게 되면 그 객체는 클래스에게 가서 "내가 이 메시지를 받았다. 해당하는 메소드의 코드를 실행해라."라고 말한다. 이것은 컴파일 중에 실행할 메소드를 결정하는 다른 컴파일 언어와는 다르다.   
객체는 어떻게 자신을 만든 클래스를 아는 걸까? 그것은 isa 포인터 때문이다. 모든 객체는 isa라는 인스턴스 변수를 가진다. 객체가 만들어지면 객체를 만든 클래스는 반환된 객체의 isa 변수를 다시 자신을 가리키도록 설정한다. 객체는 그 클래스의 하나의 인스턴스 ("is a"instance) 이기 때문에 isa 포인터라 불린다. 명시적으로 isa 포인터를 사용하지는 않겠지만 isa포인터의 존재는 objc를 강하게 만든다..(뭐지....자바도 비슷한거같은데).  
객체는 자신의 클래스(isa 포인터가 가리키는)가 해당 메소드를 구현한 메시지에만 응답한다. 이것이 실행 중에 발생하기 때문에 Xcode는 컴파일 중에 객체가 메시지에 응답할지 여부를 알 수 없다. Xcode는 응답하지 않을 객체에 메시지를 보내고 있다고 여기면 오류를 발생시킬 것이다. 하지만 확실하지 않다고 여기면 프로그램을 그대로 빌드할 것이다.   
어떤 이유로든 (많은 이유가 있겠지만)응답하지 않는 객체에 메시지를 보내면 프로그램 예외(exception)가 발생할 것이다. 예외는 컴파일 중에 발생하는 컴파일 타임 오류(compile time errors)와 달리 프로그램을 실행하고 나서 발생하기 때문에 런타임 오류(run-time errors)로 알려져 있다. 


        //예외 발생 테스트용 코드
        id lastObj = [items lastObject];
        //lastObj는 BNRItem 인스턴스이고 count 메시지를 인식하지 못한다.
        [lastObj count];   
 2022-12-07 16:01:30.607205+0900 RandomItems[8169:25103030] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[BNRItem count]: unrecognized selector sent to instance 0x600000c00d80'.  
예외란 이와 같다. 정확히 무슨 내용일까? 먼저 프로그램의 날짜, 시간, 이름을 알려줌. 이러한 건 무시해도됨. 별 세개 이후에 오는 내용에 집중해야함. 이줄에 예외가 발생한 이유를 알려줌.   
예외 발생 원인이 예외 로그에서 가장 중요한 부분임.ㅣ 이 경우 예외 발생 원인은 인식할 수 없는 셀렉터(unrecognized selector)가 인스턴스로 보내졌다는 것이다. 메시지가 의미하는 셀렉터가 뭔지 알 것이다. 앞서 객체가 구현하지 않는 메소드에 대한 메시지를 보냈다.   
items는 배열인데 마지막 원소는 인스턴스 변수임. 인스턴스 변수에서 count라는 함수는 구현되어있지 않음. 배열에 구현되잇지. 그래서 인식할 수 없는 셀렉터인것임.   

디버깅을 돕기 위해 리시버의 타입과 메시지의 이름도 콘솔에 함깨 출력됬다. BNRItem인스턴스는 count 메시지를 받았다. 앞의 -기호는 리시버가 BNRItem 인스턴스라는것을 알려준다. +기호는 클래스 그 자체가 리시버라는 것을 의미한다.   
이 예제에는 두가지 중요한 교휸이 담겨있다. 먼저 프로그램이 중단되거나 크래시가 발생하면 항상 콘솔을 확인하라는 것이다. 컴파일 중에 발생하는 오류만큼 런타임 오류(예외)도 중요하다. 둘째 unrecognized selector가 리시버가 구현하지 않는 메소드에 대해 메시지를 받았다는 것을 뜻함을 기억하자. 이런 실수를 자주 하기 때문에 기억해두면 빠르게 문제를 파악할수 있을지도 모른다 .   
일부 언어 이를태면 자바에선 예외를 처리하기 위해 트라이 캐치블럭을 사용하는데 옵씨에서도 가능은 하지만 자주 사용하지는 않음. 일반적으로 예외는 프로그램의 오류로 보고 실행중에 처리하기보다 코드를 수정해야함. (아무래도 모바일과 웹환경의 차이이지 않을까 생각됨.웹에 비해 모바일은 상대적으로 제한된 성능이니깐...?)

